import{createRequire as t}from"module";var e,i,n={562:t=>{t.exports=require("caporal")},147:t=>{t.exports={i8:"1.0.0"}}},a={};function o(t){var e=a[t];if(void 0!==e)return e.exports;var i=a[t]={exports:{}};return n[t](i,i.exports,o),i.exports}o.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return o.d(e,{a:e}),e},i=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,o.t=function(t,n){if(1&n&&(t=this(t)),8&n)return t;if("object"==typeof t&&t){if(4&n&&t.__esModule)return t;if(16&n&&"function"==typeof t.then)return t}var a=Object.create(null);o.r(a);var s={};e=e||[null,i({}),i([]),i(i)];for(var r=2&n&&t;"object"==typeof r&&!~e.indexOf(r);r=i(r))Object.getOwnPropertyNames(r).forEach((e=>s[e]=()=>t[e]));return s.default=()=>t,o.d(a,s),a},o.d=(t,e)=>{for(var i in e)o.o(e,i)&&!o.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},o.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),o.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{const e=require("@electra/utility"),i=require("typeorm");class n{dataSource;constructor(t){this.dataSource=new i.DataSource(t)}async initialize(){await this.dataSource.initialize()}async destroy(){await this.dataSource.destroy()}}class a{entityManager;constructor(t){this.entityManager=t}}var s=function(t,e,i,n){var a,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,i,n);else for(var r=t.length-1;r>=0;r--)(a=t[r])&&(s=(o<3?a(s):o>3?a(e,i,s):a(e,i))||s);return o>3&&s&&Object.defineProperty(e,i,s),s},r=function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};let c=class{id=null;group=null;name=null;executed=null;batch=null;created=null;updated=null};s([(0,i.PrimaryGeneratedColumn)(),r("design:type",Number)],c.prototype,"id",void 0),s([(0,i.Column)(),r("design:type",String)],c.prototype,"group",void 0),s([(0,i.Column)(),r("design:type",String)],c.prototype,"name",void 0),s([(0,i.Column)(),r("design:type",String)],c.prototype,"executed",void 0),s([(0,i.Column)(),r("design:type",Number)],c.prototype,"batch",void 0),s([(0,i.Column)(),r("design:type",String)],c.prototype,"created",void 0),s([(0,i.Column)(),r("design:type",String)],c.prototype,"updated",void 0),c=s([(0,i.Entity)("migration")],c);class l{id=null;group=null;name=null;executed=null;batch=null;created=null;updated=null}const u=require("luxon");class d extends a{async getAll(){return this.toEntityMap(await this.entityManager.find(c))}async getById(t){return this.toEntity(await this.entityManager.findOneBy(c,{id:t}))}async getLatestBatch(){const t=await this.entityManager.createQueryBuilder(c,"migration").select("MAX(migration.batch)","maxBatch").getRawOne();return t&&t.maxBatch?parseInt(t.maxBatch):null}async getAllByBatch(t){return this.toEntityMap(await this.entityManager.createQueryBuilder(c,"m").where("m.batch = :batch",{batch:t}).orderBy("executed","DESC").getMany())}async remove(...t){await this.entityManager.remove(t.map((t=>this.toModel(t))))}async save(...t){await this.entityManager.save(t.map((t=>{const e=u.DateTime.now().toSQL({includeOffset:!1});return t.id||(t.created=e),t.updated=e,this.toModel(t)})))}toEntityMap(t){const e={};return t.forEach((t=>{e[t.id]=this.toEntity(t)})),e}toEntity(t){return e.Objects.hydrate(new l,t)}toModel(t){return e.Objects.hydrate(new c,t)}getModel(){return c}}class h extends n{constructor(t){super({type:"mysql",database:t.database,host:t.host,port:t.port,username:t.username,password:t.password,entities:[c]})}async transaction(t){await this.dataSource.transaction((async e=>{const i={migration:new d(e)};return t(i)}))}getMigrationRepository(){return new d(this.dataSource.manager)}}const p=t(import.meta.url)("path");var g=o.n(p);const y=t(import.meta.url)("fs");var m,f,w,b=o.n(y);class E{static async import(e){return console.log(`__non_webpack_require__('${e}')`),t(import.meta.url)(`${e}`)}}class T{static config;static migrationDb;static async ensureMigrationDbExists(){const t=this.getMigrationDbConnectionOptions(),e=new i.DataSource({type:"mysql",host:t.host,port:t.port,username:t.username,password:t.password});await e.initialize();const n=e.createQueryRunner();await n.connect(),await n.query(`CREATE DATABASE IF NOT EXISTS ${t.database};`),await n.query(`USE ${t.database}`),await n.query("\n      CREATE TABLE IF NOT EXISTS migration (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        `group` VARCHAR(255) NOT NULL,\n        name VARCHAR(255) NOT NULL,\n        executed DATETIME NOT NULL,\n        batch INT NOT NULL,\n        created DATETIME NOT NULL,\n        updated DATETIME NOT NULL\n      ) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n      "),await n.release(),await e.destroy()}static getMigrationDb(){return this.migrationDb||(this.migrationDb=new h(this.getMigrationDbConnectionOptions())),this.migrationDb}static async loadConfig(){try{this.config=await E.import(g().join(process.cwd(),"migrate.config.js"))}catch(t){throw new Error(`Failed to read migrate.config.js file: ${t.message}`)}const{valid:t,message:i}=e.Validators.schema({migrationDatabase:e.Validators.string(),connections:e.Validators.object(e.Validators.schema({host:e.Validators.string(),port:e.Validators.integer(),username:e.Validators.string(),password:e.Validators.string(),databases:e.Validators.array(e.Validators.string())})),migrationDirs:e.Validators.object(e.Validators.schema({name:e.Validators.string(),path:e.Validators.string()}))}).validate(this.config);if(!t)throw new Error(`Invalid migrate.config.js file: ${i}`);return this.config}static getConfig(){if(!this.config)throw new Error("Config not loaded");return this.config}static async getProjectMigrations(t){const e={},i=this.getConfig().migrationDirs,n=await this.getMigrationDb().getMigrationRepository().getAll();for(const a in i){e[a]=[];const{name:o,path:s}=i[a];let r;const c=g().join(process.cwd(),s);try{r=await b().promises.readdir(c)}catch(t){throw new Error(`Failed to read migration directory ${s}: ${t.message}`)}for(const i of r){const[s]=i.split("."),r=Object.values(n).find((t=>t.name===s));if(!1===t?.includeExecuted&&r?.executed)continue;const l={filepath:`${c}/${i}`,group:a,groupDisplayName:o,name:s,executed:r?.executed||null,batch:r?.batch||null};e[a].push(l)}}return e}static getMigrationDbConnectionOptions(){const t=this.getConfig(),{migrationDatabase:e}=t;let i;for(const n in t.connections)if(t.connections[n].databases.includes(e)){if(i)throw new Error(`Multiple connections found for migration database "${e}"`);i=t.connections[n]}if(!i)throw new Error(`Cannot connect to migration database - no connection found for database "${e}"`);return{database:e,host:i.host,port:i.port,username:i.username,password:i.password}}}!function(t){t.INT="INT",t.TINYINT="TINYINT",t.SMALLINT="SMALLINT",t.MEDIUMINT="MEDIUMINT",t.BIGINT="BIGINT"}(m||(m={}));class L{validateName(t){const{valid:i,message:n}=e.Validators.string().validate(t);if(!i)throw new TypeError(`Invalid ${this.constructor.name} name: ${n}`);return!0}validateOptions(t,i){const{valid:n,message:a}=e.Validators.schema(i).validate(t);if(!n)throw new TypeError(`Invalid ${this.constructor.name} options. ${a}`);return!0}}class N extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={type:m.INT,nullable:!1,default:void 0,unsigned:!1,autoIncrement:!1,zeroFill:!1,primaryKey:!1,index:!1,...i},this.validateOptions(this.options,{type:e.Validators.enumValue(m),nullable:e.Validators.boolean(),default:e.Validators.integer({optional:!0}),unsigned:e.Validators.boolean(),autoIncrement:e.Validators.boolean(),zeroFill:e.Validators.boolean(),primaryKey:e.Validators.boolean(),index:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} ${this.options.type}`;this.options.nullable?n+=" NULL":n+=" NOT NULL",void 0!==this.options.default&&(n+=` DEFAULT ${this.options.default}`),this.options.unsigned&&(n+=" UNSIGNED"),this.options.autoIncrement&&(n+=" AUTO_INCREMENT"),this.options.zeroFill&&(n+=" ZEROFILL"),this.options.primaryKey&&(n+=" PRIMARY KEY"),this.options.index&&(n+=" INDEX"),i?await t.query(`CREATE TABLE IF NOT EXISTS ${e} (${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}class A extends N{constructor(t){super(t,{type:m.INT,nullable:!1,default:void 0,unsigned:!1,autoIncrement:!0,zeroFill:!1,primaryKey:!0,index:!1})}}class I extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={nullable:!1,default:void 0,unsigned:!1,zeroFill:!1,precision:10,scale:2,index:!1,...i},this.validateOptions(this.options,{nullable:e.Validators.boolean(),default:e.Validators.number({optional:!0}),unsigned:e.Validators.boolean(),zeroFill:e.Validators.boolean(),precision:e.Validators.integer(),scale:e.Validators.integer(),index:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} DECIMAL(${this.options.precision}, ${this.options.scale})`;this.options.nullable?n+=" NULL":n+=" NOT NULL",void 0!==this.options.default&&(n+=` DEFAULT ${this.options.default}`),this.options.unsigned&&(n+=" UNSIGNED"),this.options.zeroFill&&(n+=" ZEROFILL"),this.options.index&&(n+=" INDEX"),i?await t.query(`CREATE TABLE IF NOT EXISTS ${e} (${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}!function(t){t.CHAR="CHAR",t.VARCHAR="VARCHAR",t.TEXT="TEXT",t.TINYTEXT="TINYTEXT",t.MEDIUMTEXT="MEDIUMTEXT",t.LONGTEXT="LONGTEXT"}(f||(f={}));class v extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={type:f.VARCHAR,nullable:!1,primaryKey:!1,default:void 0,length:i?.type&&i?.type!==f.VARCHAR?void 0:255,index:!1,...i},this.validateOptions(this.options,{type:e.Validators.enumValue(f),nullable:e.Validators.boolean(),primaryKey:e.Validators.boolean(),default:e.Validators.string({optional:!0}),length:e.Validators.integer({optional:!0}),index:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} ${this.options.type}`;this.options.type!==f.CHAR&&this.options.type!==f.VARCHAR||void 0!==this.options.length&&(n+=`(${this.options.length})`),this.options.nullable?n+=" NULL":n+=" NOT NULL",this.options.primaryKey&&(n+=" PRIMARY KEY"),void 0!==this.options.default&&(n+=` DEFAULT ${this.options.default}`),this.options.index&&(n+=" INDEX"),i?await t.query(`CREATE TABLE IF NOT EXISTS ${e}(${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}class M extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={nullable:!1,default:void 0,index:!1,...i},this.validateOptions(this.options,{nullable:e.Validators.boolean(),default:e.Validators.regex(/^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/,"YYYY-MM-DD",{optional:!0}),index:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} DATE`;this.options.nullable?n+=" NULL":n+=" NOT NULL",void 0!==this.options.default&&(n+=` DEFAULT ${this.options.default}`),this.options.index&&(n+=" INDEX"),i?await t.query(`CREATE TABLE IF NOT EXISTS ${e}(${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}class O extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={nullable:!1,default:void 0,...i},this.validateOptions(this.options,{nullable:e.Validators.boolean(),default:e.Validators.regex(/^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/,"HH:MM:SS",{optional:!0})})}async create(t,e,i){let n=`${this.name} TIME`;this.options.nullable?n+=" NULL":n+=" NOT NULL",void 0!==this.options.default&&(n+=` DEFAULT ${this.options.default}`),i?await t.query(`CREATE TABLE IF NOT EXISTS ${e}(${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}class $ extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={nullable:!1,default:void 0,index:!1,...i},this.validateOptions(this.options,{nullable:e.Validators.boolean(),default:e.Validators.regex(/^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]) ([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/,"YYYY-MM-DD HH:MM:SS",{optional:!0}),index:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} DATETIME`;this.options.nullable?n+=" NULL":n+=" NOT NULL",void 0!==this.options.default&&(n+=` DEFAULT ${this.options.default}`),this.options.index&&(n+=" INDEX"),i?await t.query(`CREATE TABLE IF NOT EXISTS ${e}(${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}!function(t){t.BLOB="BLOB",t.TINYBLOB="TINYBLOB",t.MEDIUMBLOB="MEDIUMBLOB",t.LONGBLOB="LONGBLOB"}(w||(w={}));class D extends L{name;options;constructor(t,i){super(),this.name=t,this.validateName(this.name),this.options={type:w.BLOB,nullable:!1,...i},this.validateOptions(this.options,{type:e.Validators.enumValue(w),nullable:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} ${this.options.type}`;this.options.nullable?n+=" NULL":n+=" NOT NULL",i?await t.query(`CREATE TABLE IF NOT EXISTS ${e}(${n});`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n};`)}}class x extends L{name;values;options;constructor(t,i,n){super(),this.name=t,this.validateName(this.name),this.values=i;const{valid:a,message:o}=e.Validators.all([e.Validators.array(e.Validators.string()),e.Validators.minLength(1)]).validate(this.values);if(!a)throw new TypeError(`Invalid ${this.constructor.name} values. ${o}`);this.options={nullable:!1,default:void 0,index:!1,...n};const s={};for(const t of this.values)s[t]=t;this.validateOptions(this.options,{nullable:e.Validators.boolean(),default:e.Validators.enumValue(s,{optional:!0}),index:e.Validators.boolean()})}async create(t,e,i){let n=`${this.name} ENUM('${this.values.join("', '")}')`;this.options.nullable?n+=" NULL":n+=" NOT NULL",void 0!==this.options.default&&(n+=` DEFAULT '${this.options.default}'`),this.options.index&&(n+=" INDEX"),i?await t.query(`CREATE TABLE ${e} (${n})`):await t.query(`ALTER TABLE ${e} ADD COLUMN ${n}`)}}class R{name;connection;operations=[];tableExists;constructor(t,e,i,n){this.name=t,this.connection=e,this.operations=i,this.tableExists=n}id(t="id"){return this.operations.push((async()=>{const e=new A(t);await e.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}int(t,e){return this.operations.push((async()=>{const i=new N(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}decimal(t,e){return this.operations.push((async()=>{const i=new I(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}string(t,e){return this.operations.push((async()=>{const i=new v(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}enum(t,e,i){return this.operations.push((async()=>{const n=new x(t,e,i);await n.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}date(t,e){return this.operations.push((async()=>{const i=new M(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}time(t,e){return this.operations.push((async()=>{const i=new O(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}datetime(t,e){return this.operations.push((async()=>{const i=new $(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}blob(t,e){return this.operations.push((async()=>{const i=new D(t,e);await i.create(this.connection,this.name,!this.tableExists),this.tableExists=!0})),this}async execute(){for(const t of this.operations)await t()}}class C{connection;operations;constructor(t,e){this.connection=t,this.operations=e}create(t){return new R(t,this.connection,this.operations,!1)}table(t){return new R(t,this.connection,this.operations,!0)}drop(t){return this.operations.push((async()=>{await this.connection.query(`DROP TABLE ${t};`)})),this}async execute(){for(const t of this.operations)await t()}}class B{connections;operations=[];constructor(t){this.connections=t}database(t,e){let i;if(e)i=this.connections.get(e);else{const e=this.connections.getAllByDatabaseName(t);if(0===e.length)throw new Error(`No connections found for database "${t}"`);if(e.length>1)throw new Error(`Multiple connections found for database "${t}". Connection name must be specified.`);i=e[0]}return this.operations.push((async()=>{await i.query(`CREATE DATABASE IF NOT EXISTS ${t};`)})),this.operations.push((async()=>{await i.query(`USE ${t};`)})),new C(i,this.operations)}}class V{connectionConfig;connection;queryRunner;startTransactionOnInit=!1;constructor(t,e=!1){this.connectionConfig=t,this.startTransactionOnInit=e}async query(t,e=[]){return(await this.get()).query(t,e)}async destroy(){this.queryRunner&&(await this.queryRunner.release(),this.queryRunner=void 0),this.connection&&(await this.connection.destroy(),this.connection=void 0)}async startTransaction(){if(this.queryRunner)throw new Error("Transaction already started.");console.log("starting transaction");const t=await this.get();this.queryRunner=t.createQueryRunner(),await this.queryRunner.startTransaction()}async commitTransaction(){await this.queryRunner.commitTransaction(),await this.queryRunner.release(),this.queryRunner=void 0}async rollbackTransaction(){await this.queryRunner.rollbackTransaction(),await this.queryRunner.release(),this.queryRunner=void 0}isInitialised(){return!!this.connection}async get(){return this.connection||(this.connection=new i.DataSource({type:"mysql",host:this.connectionConfig.host,port:this.connectionConfig.port,username:this.connectionConfig.username,password:this.connectionConfig.password}),await this.connection.initialize(),console.log("Connection initialised"),this.startTransactionOnInit&&await this.startTransaction()),this.connection}}class S{config={};connections={};startTransactionOnInit=!1;constructor(t,e=!1){this.config=t,this.startTransactionOnInit=e}get(t){if(this.connections[t])return this.connections[t];if(!this.config[t])throw new Error(`Config for connection "${t}" not found`);const{host:e,port:i,username:n,password:a}=this.config[t];return this.connections[t]=new V({host:e,port:i,username:n,password:a},this.startTransactionOnInit),this.connections[t]}getAllByDatabaseName(t){const e=[];for(const i in this.config)this.config[i].databases.includes(t)&&e.push(this.get(i));return e}getAllInitialised(){return Object.values(this.connections).filter((t=>t.isInitialised()))}}const U=require("chalk");var q=o.n(U);class j{static async status(){const t=T.getConfig().migrationDirs,e=await T.getProjectMigrations();for(const i in e){const n=e[i],{name:a}=t[i];if(console.log(q().yellowBright(a)),0!==n.length)for(const t of n)console.log(`  ${t.executed?q().green(t.name):q().redBright(t.name)}`);else console.log(q().redBright("  * No migrations found *"))}}static async migrate(){const t=await T.getProjectMigrations({includeExecuted:!1});if(0===Object.keys(t).length)return void console.log(q().blueBright("No migrations to run"));const e=T.getConfig(),i=new S(e.connections,!0),n=await T.getMigrationDb().getMigrationRepository().getLatestBatch(),a=n?n+1:1,o=new B(i),s=[];try{for(const e in t){const i=t[e];for(const t of i){if(t.executed)continue;const e=await this.getMigrationClassInstance(t);await e.up(o);const i=new l;i.name=t.name,i.group=t.group,i.executed=u.DateTime.now().toSQL({includeOffset:!1}),i.batch=a,s.push(i)}}const e=i.getAllInitialised();for(const t of e)await t.commitTransaction();await T.getMigrationDb().getMigrationRepository().save(...s),console.log(q().green(`Successfully ran ${s.length} migration${1!==s.length?"s":""}`))}catch(t){console.log(q().redBright(`Failed to run migrations: ${t.message}`)),console.log(t.stack);const e=i.getAllInitialised();for(const t of e)await t.rollbackTransaction()}const r=i.getAllInitialised();for(const t of r)await t.destroy()}static async rollback(){const t=await T.getMigrationDb().getMigrationRepository().getLatestBatch();if(!t)return void console.log(q().blueBright("No migrations to rollback"));const e=T.getConfig(),i=new S(e.connections,!0),n=new B(i),a=[],o=await T.getProjectMigrations(),s=await T.getMigrationDb().getMigrationRepository().getAllByBatch(t);if(0===Object.keys(s).length)return void console.log(q().blueBright("No migrations to roll back"));try{for(const t of Object.values(s)){const e=o[t.group].find((e=>e.name===t.name)),i=await this.getMigrationClassInstance(e);await i.down(n),a.push(t)}const t=i.getAllInitialised();for(const e of t)await e.commitTransaction();await T.getMigrationDb().getMigrationRepository().remove(...a),console.log(q().green(`Successfully rolled back ${a.length} migration${1!==a.length?"s":""}`))}catch(t){console.log(q().redBright(`Failed to run migrations: ${t.message}`));const e=i.getAllInitialised();for(const t of e)await t.rollbackTransaction()}const r=i.getAllInitialised();for(const t of r)await t.destroy()}static async getMigrationClassInstance(t){const e=await E.import(t.filepath);let i;if("function"==typeof e&&e.prototype&&e.prototype.constructor)i=e;else{const n=t.name.split("_").pop();if(e[n])i=e[n];else{if(!e.default)throw new Error(`Could not find migration class in ${t.filepath}`);i=e.default}}return new i}}function F(t){return async(e,i,n)=>{await T.ensureMigrationDbExists(),await T.getMigrationDb().initialize(),await t(e,i,n),await T.getMigrationDb().destroy()}}require("reflect-metadata"),(async()=>{await T.loadConfig();const{default:t}=await Promise.resolve().then(o.t.bind(o,562,23));try{t.name("Electra Migrate").description("MySQL Migrations for Node.js Applications").version(o(147).i8),t.command("status","Show the status of all migrations").action(F((async()=>{await j.status()}))),t.command("migrate","Run all migrations").action(F((async()=>{await j.migrate()}))),t.command("rollback","Rollback the last batch of migrations").action(F((async()=>{await j.rollback()}))),t.parse(process.argv)}catch(t){console.log(q().red(t.stack))}})()})();